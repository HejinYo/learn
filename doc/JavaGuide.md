# java
## 一、基础

### 1、面向对象
+ 类: 具有相同的属性和功能的对象的抽象的几集合
+ 字段: private 私有变量
+ 属性: public 共有变量

#### 封装:
> 将抽象性函式接口的实现细节部份包装、隐藏起来的方法

+ public：可以被所有其他类所访问
+ private：只能被自己访问和修改
+ protected：自身、子类及同一个包中类可以访问
+ default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。

#### 继承: 
> 是一种类与类之间强耦合的关系，一个类是另一个类的特殊种类，适用继承。

#### 多态: 
> 表示不同对象可以执行相同的动作，但要通过它们自己的实现代码来执行

#### 抽象类:
> 不能实例化 ，抽象方法是必须被子类重写，抽象类尽可能总有多的共同代码，尽可能少的数据，具体类不是用来继承的

#### 接口: 
> 把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就支持接口所指定的所有属性和成员。
不能实例化，不能有构造方法和字段，不能有修饰符，实现接口必须实现接口中的所有方法和属性

类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象
+ 一、接口对类的局部（行为）进行抽象，抽象类对类的整体（字段，属性，方法）的抽象
+ 二、行为跨越不同类的对象，可使用接口；对于一些相似的类对象用继承抽象类
+ 三、从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口根本不知子类的存在，方法如何实现还不确认，预先定义。

#### final 关键字
final关键字主要用在三个地方：变量、方法、类。

+ 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

+ 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

+ 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

#### static 关键字
static 关键字主要有以下四种使用场景：

+ 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
+ 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
+ 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
+ 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。
## 、J2EE
### JSP有9个内置对象：
+ request：封装客户端的请求，其中包含来自GET或POST请求的参数；
+ response：封装服务器对客户端的响应；
+ pageContext：通过该对象可以获取其他对象；
+ session：封装用户会话的对象；
+ application：封装服务器运行环境的对象；
+ out：输出服务器响应的输出流对象；
+ config：Web应用的配置对象；
+ page：JSP页面本身（相当于Java程序中的this）；
+ exception：封装页面抛出异常的对象。

### JSP中的四种作用域：
+ page代表与一个页面相关的对象和属性。
+ request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。
+ session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。
+ application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。

### ListIterator迭代器的概述

+ ListIterator与Iterator接口不同，它不仅可以向后迭代，它还可以向前迭代。
+ ListIterator相对Iterator增加了如下3个方法：
+ boolean hasPrevious()：返回该迭代器关联的集合是否还有上一个元素。
+ Object previous()：返回该迭代器的上一个元素。
+ void add()：在指定位置插入一个元素

### map
#### HashMap
+ 根据键的hashCode的值存储数据，有很快的访问速度，但是遍历顺序是不确定的
+ 允许一个key为null，多个value为null
+ 非线程安全，可以使用Conllections的SynchonizedMap方法使HashMap具有线程安全能力，或者使用ConcurrentHashMap;
#### Hashtable
+ 继承Dictionay类，基本和HashMap类似，但是线程安全，性能不如ConcurrentHashMap;
+ 不允许key或value为null
#### LinkedHashMap
+ HashMap的子类，保存了记录的插入顺序，Iterator遍历时得到的记录是插入顺序
+ 允许一个key为null，多个value为null
+ 可以在构造函数时带入参数，按照访问次序排序
#### TreeMap
+ 能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。
+ 如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。
