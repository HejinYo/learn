# 11.6 JSON数据类型
## 注意事项
> JSON列不能有默认值。

> 与JSON数据类型一起，可以使用一组SQL函数启用对JSON值的操作，例如创建，操作和搜索。以下讨论显示这些操作的示例。有关各个函数的详细信息，请参见第12.16节“JSON函数”。

> 还可以使用一组用于GeoJSON值操作的空间函数。请参见第12.15.11节“空间GeoJSON函数”。

> JSON列，如其他二进制类型的列，不直接索引; 相反，您可以在生成的列上创建索引，从列中提取标量值 JSON。有关详细示例，请参阅 索引生成的列以提供JSON列索引。

> MySQL优化器还在符合JSON表达式的虚拟列上查找兼容的索引。

> MySQL NDB Cluster 7.5（7.5.2和更高版本）支持 JSON列和MySQL JSON函数，包括在列中生成的JSON列上创建索引 ，作为无法索引JSON列的解决方法。JSON每个NDB表最多支持3 列 。

## 创建JSON值
JSON数组包含由逗号分隔并包含在内 [ ] 字符中的值列表：
```
["abc", 10, null, true, false]
```
JSON对象包含一组用逗号分隔的键值对，并且包含在内{ }字符中：
```
{"k1": "value", "k2": 10}
```
如示例所示，JSON数组和对象可以包含字符串或数字的标量值，JSON空文本或JSON布尔真或假文字。JSON对象中的键必须是字符串。时间（日期，时间或日期时间）标量值也是允许的：

```
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
```
在JSON数组元素和JSON对象键值中允许嵌套：
```
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
```

+ JSON_TYPE()函数需要一个JSON参数并尝试将其解析为JSON值。如果该值有效，则返回值的JSON类型，否则会产生错误;
```text
mysql> SELECT JSON_TYPE('["a", "b", 1]');
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+
```
+ 作为使用文字字符串编写JSON值的替代方法，存在用于编写来自组件元素的JSON值的函数。 JSON_ARRAY（）接受一个（可能为空的）值列表并返回一个包含这些值的JSON数组：
```text
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
```

+ JSON_MERGE（）接受两个或更多JSON文档并返回组合结果：
```text
mysql> SELECT JSON_MERGE('["a", 1]', '{"key": "value"}');
+--------------------------------------------+
| JSON_MERGE('["a", 1]', '{"key": "value"}') |
+--------------------------------------------+
| ["a", 1, {"key": "value"}]                 |
+--------------------------------------------+
```


+ 有时可能需要或希望将引号字符（"或'）插入到JSON文档中。假设你想插入一些包含字符串的JSON对象，这些字符串表示一些关于MySQL的关于MySQL的事实，每个事实都与一个合适的关键字配对成一个使用这里显示的SQL语句创建的表格：
```text
mysql> CREATE TABLE facts (sentence JSON);
```
+ 在这些关键字 - 句子对之中是这一个：
```text
mascot: The MySQL mascot is a dolphin named "Sakila".
```
+ 将其作为JSON对象插入facts表中的一种方法 是使用MySQL JSON_OBJECT()函数。在这种情况下，您必须使用反斜杠来转义每个引号字符，如下所示：
```text
mysql> INSERT INTO facts VALUES
     >   (JSON_OBJECT("mascot", "Our mascot is a dolphin named \"Sakila\"."));
```
+ 如果将该值作为JSON对象文本插入，则这种方式不起作用，在这种情况下，必须使用双反斜杠转义序列，如下所示：
```text
mysql> INSERT INTO facts VALUES
     >   ('{"mascot": "Our mascot is a dolphin named \\"Sakila\\"."}');
```
+ 使用双反斜杠使MySQL不会执行转义序列处理，而是使其将字符串文字传递给存储引擎进行处理。以上述任何一种方式插入JSON对象后，通过执行一个简单的操作就可以看到反斜杠存在于JSON列值中SELECT，如下所示：
```text
mysql> SELECT sentence FROM facts;
+---------------------------------------------------------+
| sentence                                                |
+---------------------------------------------------------+
| {"mascot": "Our mascot is a dolphin named \"Sakila\"."} |
+---------------------------------------------------------+
```

## 搜索和修改JSON值
### JSON路径表达式在JSON文档中选择一个值。
路径表达式对于提取部分或修改JSON文档的函数非常有用，以指定要在该文档中的何处进行操作。例如，以下查询从JSON文档中提取具有该name键的成员的值 ：
```text
mysql> SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
```
+ 路径可以包含*或 **通配符：
> .[*] 评估JSON对象中所有成员的值。
> [*] 评估为JSON数组中所有元素的值。
> prefix**suffix 评估所有以命名前缀开头并以命名后缀结尾的路径。
> 文档中不存在的路径（评估为不存在的数据）评估为NULL。

+ JSON_SET() 替换存在路径的值并为不存在的路径添加值:.
```text
mysql> SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
```
+ 在这种情况下，路径将$[1].b[0]选择一个现有值（true），该值将替换为路径参数（1）后面的值。路径$[2][2]不存在，所以相应的值（2）被添加到所选的值$[2]。

+ JSON_INSERT() 增加了新的值，但并未取代现有值：
```text

mysql> SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
```
+ JSON_REPLACE() 替换现有值并忽略新值：
```text

mysql> SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
```
路径/值对从左到右进行评估。通过评估一对产生的文件成为评估下一对的新值。

+ JSON_REMOVE()需要一个JSON文档和一个或多个指定要从文档中删除的值的路径。返回值是原始文档减去文档中存在的路径选择的值：
```text
mysql> SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
```
> 路径有这些影响：

+ $[2]匹配[10, 20] 并删除它。

+ 第一个实例$[1].b[1]相匹配 false的b元素并将其删除。

+ 第二个实例$[1].b[1]没有匹配：该元素已被删除，该路径不再存在，并且没有任何作用。

> JSON值的比较和排序
+ JSON值可以使用进行比较 =， <， <=， >， >=， <>， !=，和 <=> 运营商。




















