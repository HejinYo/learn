# java
## 一、基础

### 1、面向对象
+ 类: 具有相同的属性和功能的对象的抽象的几集合
+ 字段: private 私有变量
+ 属性: public 共有变量

#### 封装:
> 将抽象性函式接口的实现细节部份包装、隐藏起来的方法

+ public：可以被所有其他类所访问
+ private：只能被自己访问和修改
+ protected：自身、子类及同一个包中类可以访问
+ default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。

#### 继承: 
> 是一种类与类之间强耦合的关系，一个类是另一个类的特殊种类，适用继承。

#### 多态: 
> 表示不同对象可以执行相同的动作，但要通过它们自己的实现代码来执行

#### 抽象类:
> 不能实例化 ，抽象方法是必须被子类重写，抽象类尽可能总有多的共同代码，尽可能少的数据，具体类不是用来继承的

#### 接口: 
> 把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就支持接口所指定的所有属性和成员。
不能实例化，不能有构造方法和字段，不能有修饰符，实现接口必须实现接口中的所有方法和属性

类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象
+ 一、接口对类的局部（行为）进行抽象，抽象类对类的整体（字段，属性，方法）的抽象
+ 二、行为跨越不同类的对象，可使用接口；对于一些相似的类对象用继承抽象类
+ 三、从设计角度讲，抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口根本不知子类的存在，方法如何实现还不确认，预先定义。

#### final 关键字
final关键字主要用在三个地方：变量、方法、类。

+ 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

+ 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。

+ 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

#### static 关键字
static 关键字主要有以下四种使用场景：

+ 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
+ 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
+ 静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
+ 静态导包(用来导入类中的静态资源，1.5之后的新特性): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。
## 、J2EE
### JSP有9个内置对象：
+ request：封装客户端的请求，其中包含来自GET或POST请求的参数；
+ response：封装服务器对客户端的响应；
+ pageContext：通过该对象可以获取其他对象；
+ session：封装用户会话的对象；
+ application：封装服务器运行环境的对象；
+ out：输出服务器响应的输出流对象；
+ config：Web应用的配置对象；
+ page：JSP页面本身（相当于Java程序中的this）；
+ exception：封装页面抛出异常的对象。

### JSP中的四种作用域：
+ page代表与一个页面相关的对象和属性。
+ request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。
+ session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。
+ application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。


+ Runnable接口不会返回结果但是Callable接口可以返回结果。

 ### Executor 框架的使用示意图
#### 1、主线程首先要创建实现Runnable或者Callable接口的任务对象。
> 备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。

#### 2、然后可以把创建完成的Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callable task））。

#### 执行execute()方法和submit()方法的区别是什么呢？
+ 1)execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
+ 2)submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

#### 3、如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（我们刚刚也提到过了执行execute()方法和submit()方法的区别，到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。

#### 4、最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。




