# Redis
## Redis LRU算法
### Maxmemory配置指令
maxmemory配置指令用于配置Redis存储数据时指定限制的内存大小
设置maxmemory为0代表没有内存限制。对于64位的系统这是个默认值，对于32位的系统默认内存限制为3GB
+ maxmemory 100mb

### redis 设置过期时间

定期删除+惰性删除
+ 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，
检查其是否过期，如果过期就删除。注意这里是随机抽取的。
为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
+ 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。
所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，
除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

### 回收策略
当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。

以下的策略是可用的:

+ no-eviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
+ allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
+ volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
+ allkeys-random: 回收随机的键使得新添加的数据有空间存放。
+ volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
+ volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。

选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。

一般的经验规则:

+ 使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.
+ 使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。
+ 使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。
+ allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。

+ 为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。


## Redis 事务
MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令

MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。

另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。

使用 check-and-set 操作实现乐观锁
WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为


## redis 持久化
Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）

# RabbitMq

## Exchange 类型
四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：

+ direct : 路由键与队列名完全匹配,是完全匹配、单播的模式
+ fanout : 每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去
+ topic : 将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配不多不少一个单词

### RabbitMQ 集群
最优秀的功能之一就是内建集群,使客户端在失去一个 RabbitMQ 节点连接的情况下，还是能够重新连接到集群中的任何其他节点继续生产、消费消息

#### RabbitMQ 会始终记录以下四种类型的内部元数据：

+ 队列元数据
    包括队列名称和它们的属性，比如是否可持久化，是否自动删除
+ 交换器元数据
    交换器名称、类型、属性
+ 绑定元数据
    内部是一张表格记录如何将消息路由到队列
+ vhost 元数据
    为 vhost 内部的队列、交换器、绑定提供命名空间和安全属性
    
 单一节点中，这些信息存储在内存中，同时将标记为可持久化的队列、交换器、绑定存储到硬盘上。存到硬盘上可以确保队列和交换器在节点重启后能够重建。
 
 而在集群模式下同样也提供两种选择：存到硬盘上（独立节点的默认设置），存在内存中。
 
 在集群中创建队列，集群只会在单个节点而不是所有节点上创建完整的队列信息（元数据、状态、内容）
 
 RabbitMQ 2.6.0之后提供了镜像队列以避免集群节点故障导致的队列内容不可用
 

 RabbitMQ 集群中可以共享 user、vhost、exchange等，所有的数据和状态都是必须在所有节点上复制的，例外就是上面所说的消息队列。RabbitMQ 节点可以动态的加入到集群中。
 
 当在集群中声明队列、交换器、绑定的时候，这些操作会直到所有集群节点都成功提交元数据变更后才返回。
 
 RabbitMQ 只要求集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入火离开集群时，它们必须要将该变更通知到至少一个磁盘节点。如果只有一个磁盘节点，刚好又是该节点崩溃了，那么集群可以继续路由消息，但不能创建队列、创建交换器、创建绑定、添加用户、更改权限、添加或删除集群节点。换句话说集群中的唯一磁盘节点崩溃的话，集群仍然可以运行，但知道该节点恢复，否则无法更改任何东西。
 
 
